%output  "parser.cxx"
%defines "parser.hxx"

/* $Id$ -*- mode: c++ -*- */
/** \file parser.yy Contains the example Bison parser source */

%code requires {
  #include "core/formula.hpp"

    // utility function to append a list element to a std::vector
  template <class T, class V>
  T&& enlist(T& t, V&& v)
  {
      t.emplace_back(std::move(v));
      return std::move(t);
  }


  template <class T>
  std::vector<T> pairtolist(T&& a, T&& b)
  {
      std::vector<T> t;
      t.emplace_back(std::move(a));
      t.emplace_back(std::move(b));
      return t;
  }
}

%{ /*** C/C++ Declarations ***/

#include <stdio.h>
#include <string>
#include <vector>


%}

/*** yacc/bison Declarations ***/

/* Require bison 2.3 or later */
%require "3.0"

/* add debug output code to generated parser. disable this for release
 * versions. */
%debug

/* start symbol is named "start" */
%start problem

/* write out a header file containing the token defines */
%defines

/* use newer C++ skeleton file */
%skeleton "lalr1.cc"

/* namespace to enclose parser in */
%define api.namespace {theseus::tptp}

/* set the parser's class identifier */
%define parser_class_name {Parser}


%define api.value.type variant

/* keep track of the current position within the input */
%locations
%initial-action
{
    // initialize the initial location object
    @$.begin.filename = @$.end.filename = &driver.streamname;
};

/* The driver is passed by reference to the parser and to the scanner. This
 * provides a simple but effective pure interface, not relying on global
 * variables. */
%parse-param { class Driver& driver }

/* verbose error messages */
%error-verbose

 /*** BEGIN EXAMPLE - Change the example grammar's tokens below ***/

%token          END      0  "end of file"
%token          EOL     "end of line"
%token <std::string>  VAR_LABEL      "variable identifier"
%token <std::string>  FUNC_LABEL     "function identifier"

%token LEFT RIGHT
%token LEFT_SQUARE RIGHT_SQUARE
%token AND OR ARROW
%token ALL SOME
%token AXIOM CONJECTURE FOF
%token NEGATION

%type <std::shared_ptr<Formula>> formula quantified_formula bracketed_formula operation_formula predicate_formula negated_formula
%type <std::vector<theseus::Identifier*>> variable_list
%type <theseus::Identifier*> variable function constant
%type <theseus::Quantifier> quantifier
%type <theseus::Operation> operator

%type <theseus::Term*> function_term term
%type <std::vector<theseus::Term*>> term_list

%type <std::shared_ptr<Formula>> definition problem

//%type <calcnode>    atomexpr powexpr unaryexpr mulexpr addexpr expr

//%destructor { delete $$; } STRING
//%destructor { delete $$; } constant variable
//%destructor { delete $$; } atomexpr powexpr unaryexpr mulexpr addexpr expr

 /*** END EXAMPLE - Change the example grammar's tokens above ***/

%{

#include "driver.hpp"
#include "scanner.hpp"

/* this "connects" the bison parser in the driver to the flex scanner class
 * object. it defines the yylex() function call to pull the next token from the
 * current lexer object of the driver context. */
#undef yylex
#define yylex driver.lexer->lex

%}

%% /*** Grammar Rules ***/

problem      : problem definition { driver.expressions.emplace_back(std::move($2)); } // TODO
             | definition { driver.expressions.emplace_back(std::move($1)); }
             ;

    /* statements */

definition   : FOF LEFT description ',' AXIOM ',' formula RIGHT '.'  {$$ = std::move($7);}
             ;

description  : FUNC_LABEL
             | VAR_LABEL
             ;

formula      : quantified_formula {$$ = std::move($1);}
             | operation_formula {$$ = std::move($1);}
             | negated_formula {$$ = std::move($1);}
             ;

negated_formula : NEGATION formula
                  {$$ = std::make_shared<theseus::FormulaNegation>(std::move($2));}
                ;

quantified_formula : quantifier LEFT_SQUARE variable_list RIGHT_SQUARE ':' formula
                     {$$ = std::make_shared<theseus::FormulaQuantifier>($1, std::move($3), std::move($6));}
                ;

operation_formula : bracketed_formula   operator operation_formula  
                    {$$ = std::make_shared<theseus::FormulaJunction>($2, std::move(pairtolist(std::move($1), std::move($3))));}
                  | bracketed_formula  {$$ = std::move($1);}
                  | predicate_formula       operator operation_formula  
                    {$$ = std::make_shared<theseus::FormulaJunction>($2, std::move(pairtolist(std::move($1), std::move($3))));}
                  | predicate_formula  {$$ = std::move($1);}
                  ;

bracketed_formula : LEFT formula RIGHT {$$ = std::move($2);}
                  ;

predicate_formula : function_term {$$ = std::make_shared<theseus::FormulaLiteral>(Literal($1));}
                 ;

quantifier : ALL { $$ = theseus::Quantifier::Universal;}
           | SOME { $$ = theseus::Quantifier::Existential;}
           ;

variable_list : variable_list ',' variable {$$ = enlist($1, std::move($3));}
              | variable {$$ = {1, $1};}
              ;

operator    : OR { $$ = theseus::Operation::Disjunction;}
            | AND { $$ = theseus::Operation::Conjunction;}
            | ARROW { $$ = theseus::Operation::Conjunction;} // TODO
            ;


function_term  : function LEFT term_list RIGHT
                  { $$ = theseus::TermDatabase::instance().get($1, $3); }
            ;

term_list   : term_list ',' term {$$ = enlist($1, std::move($3));}
            | term {$$ = {1, $1};}
            ;

term        : variable { $$ = theseus::TermDatabase::instance().get($1); }
            | function_term { $$ = $1; }
            | constant { $$ = theseus::TermDatabase::instance().get($1); }
            ;


function : FUNC_LABEL {$$ = theseus::IdentifierFactory::instance().function($1);}
         ;

constant : function {$$ = $1;}
         ;

variable : VAR_LABEL {$$ = theseus::IdentifierFactory::instance().variable($1);}
         ;
 /*** END EXAMPLE - Change the example grammar rules above ***/

%% /*** Additional Code ***/

void theseus::tptp::Parser::error(const Parser::location_type& l,
                const std::string& m)
{
    driver.error(l, m);
}